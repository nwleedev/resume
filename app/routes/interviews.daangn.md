# 당근마켓 인터뷰

30분 1시간

# 프론트엔드 개발하는 이유

개발자로서 우리가 개발한 어플리케이션이 유저들에게 도움을 주는 것을 볼 때마다 보람을 느낍니다.

굳이 백엔드가 아니더라도, URL 인코딩, BASE64, 사진에서 색상을 추출하는 웹 사이트, Mp4를 Webp등으로 컨버팅해주는 사이트... (이건 백엔드가 있었음..), 공식문서

사용자로부터 제보되는 이슈, 그리고 QA 및 디자인 담당 팀원으로부터 피드백을 적극적으로 반영하여 사용자에게 더 친화적인 프론트엔드를 개발하는 방법을 계속 생각해왔습니다.

웹 애플리케이션의 프론트엔드를 개발함으로서 우리가 개발하는 서비스로 유저들이 각자의 문제점을 해결할 수 있도록 필요한 작업을 진행했습니다.

Remix를 채택한 이유

- Vite로 구성된 리액트 프로젝트에 SSR을 적용해야 했다.
- SEO, 브라우저의 부담을 줄일 수 있다고 들었다.
- 어떻게 SSR이 작동하는지 알고 싶었다.
  - Suspense는 renderToReadableStream으로 SSR 성공했다.
- SSR을 적용하고 Loader까지 붙여봤다.
- SSR을 적용하면 외부 API가 CORS 제한이 걸려있을 때에도 문제없이 이용할 수 있다.
- Remix가 React Router DOM을 개발한 회사에서 개발한 프레임워크라는 걸 알고 있었다.
- Loader만 아니라 Action까지 파일 단위로 관리할 수 있었다.
- SSR을 구현하면서 엔트리 파일을 작성했는데 이 구조가 Remix 세팅했을 때 구조와 비슷하더라.
- 메타태그도 더 간편하게 주입 가능

  - React SSR 환경에서는 UI 컴포넌트에서 Loader Hook에서 데이터를 받아온 다음, 메타 태그를 따로 렌더링하는 컴포넌트가 있어야 했다.

- 공식문서에서는 컴포넌트와 Action을 연결할 때 input 컴포넌트마다 State를 연결시키지 않는다.
- 폼 요소가 많을 때에는 비제어되는 컴포넌트도 고려할 수 있을 거 같다.
  - 글자를 입력할 때마다 컴포넌트가 재 렌더링되기 때문
  - 에러 메시지의 경우, onChange 대신 onInput 이벤트 핸들링을 할 수 있을 것이다.

React & Fastify

- SSR은 브라우저의 부담을 줄이지만 서버의 부담을 줄 수 있다.
- 현재 오라클 클라우드에서 개인 프로젝트를 프론트엔드, 백엔드를 전부 하나의 인스턴스에 올리고 있다.
- 조금이라도 서버의 부담을 줄이고 싶었다.
- Fastify가 Express에 비해 서버의 부담을 덜 준다고 알려져있었다. (JSON 직렬화)
  - 공식문서에서도 더 가벼운 라이브러리라고 소개중이었다.
- Server 파일을 직접 작성할 경우, 개발 환경에서 실행할 때 일일이 JS로 변환하기 보다는 NodeJS에 Loader 옵션을 줘서 실행시킬 수 있다는 걸 알게됐다.
- Fastify로 성능이 나아지지 않을 때는, 현재 개인 오라클 클라우드 대신 Cloudflare Pages를 채택할 수도 있을 것 같았다.
- 미들웨어 이슈
  - Static 파일 미들웨어 제공 이슈는 index html 파일을 제외하도록 했다.
  - 압축 미들웨어를 설정했을 때 브라우저가 응답하지 않았는데 content type을 text/html로 설정했다.
- Remix Fastify의 소스 코드를 찾아봄
- 개발용일 때는 Vite 미들웨어를 설정하기 위해 middie를 설치하고, 배포할 때는 Fastify의 플러그인을 채택.

Golang을 백엔드 언어로 고른 이유

- TS만 아니라 다른 언어도 접해보고 싶었다.
- 타입스크립트보다 적은 부담, 문법도 어렵지 않았음
- 하나의 파일로 컴파일됨, 환경변수를 줌으로써 다양한 플랫폼 대응 가능
- Golang은 함수의 리턴값을 에러랑 같이 리턴 가능
- 에러를 꼭 검사하는 프로그래밍 방식이었기 때문에, 타입스크립트 프로그래밍할 때도 비동기 작업의 값이 undefined인지, null인지 확인하는 습관을 들였다.

React 사용 이유

- 단방향 데이터 흐름으로 인해 데이터가 어디서 계산되는지 확인하기 더 빠르다.
- ReactDOMServer의 존재로 SSR이 비교적 어렵지 않았다.
  - renderToString
  - Suspense가 있어야 할 경우 renderToReadableStream

Chromatic Protocol

- useSWR 힘들었던 점

  - useSWR 키를 관리할 때 클래스 인스턴스 등을 넣을 수 없었다.
  - SDK가 클래스 인스턴스를 사용하고 있어서, 인스턴스 대신 식별가능한 값을 키로 부여, 클래스는 Hooks에서 undefined인지 아닌지만 검증
  - 포지션 추가할 때 포지션 갱신을 위해 재요청을 보내는 것 보다는 입력값으로 예상되는 값을 계산하여 로컬 뮤테이션
  - 개발 초기에 자주 발생하던 429 에러 문제가 거의 발생하지 않았다.
  - 기본값으로 창이 다시 포커싱될 때 데이터를 자동으로 갱신한다. 자동으로 갱신되는 것을 막기 위해 컨트랙트의 이벤트로부터 값을 받아 로컬 뮤테이션으로 업데이트시켰다.

- 팀 내 사용하는 웹소켓 라이브러리는 10분이 넘는 시간 후 끊어지는 이슈가 있었는데, 재연결하는 로직이 없었음.

  - Patch package로 우선 라이브러리 직접 확인 후 이슈 등록
  - 핫픽스 배포 후 라이브러리 작업 확인 받음

- 숫자 포매팅

  - 콤마를 표시할 때에는 직접 세 자리 씩 끊어서 쉼표 삽입하는 방식으로 작업
  - Intl.NumberFormat, date-fns으로 리팩토링

- Blur 이벤트 대신 onClickAway 메소드 직접 작성

SolidJS

- React와 비교해서 작은 파일 크기라고 문서에서 소개됨
  - 크기가 작으면 웹 브라우저에서 더 빠르게 로딩할 수 있다.
- 개발을 진행하면서 프로젝트 규모가 커짐에 따라 빌드되는 파일의 크기도 증가한다.
- 협업이 힘들었다.
- React에서 상태가 변수였다면, Solid에서는 상태가 함수(Accessor)라서 어디서 어떤 컴포넌트가 리렌더링되는지 파악하기가 힘들었다.
- UI와 데이터 계산을 분리하는 방법을 찾지 못해 아쉬웠음

OpenAI API 프롬프트

- 그림 API를 사용할 때는 스테이블 디퓨전과는 다르게 문장 형태로 프롬프트를 줄 수 있는 점이 편리했다.
- 필수적으로 넣어야 하는 프롬프트 4줄
- 나름의 규칙을 정해놓았다.
  - 문장은 많이, 문장 당 글자 수는 8개 내외로 적게
  - 인물 및 동물의 경우 특정하는 단어를 작성한다.
  - The painting should be more clear.
  - The painting should adapt watercolor art style.
  - The painting should be extremely detailed.
  - The painting should be much more clear.
  - The painting should include 0 letters.
  - The painting should include 0 text characters.
  - X is male.
  - X is Korean.
  - X is wearing casual outfit.

초기 페이지 렌더링이 느린 이슈

- Performance 50 중반에서 70 중반으로 향상
- 메인 페이지에서는 모든 목록의 이미지를 한번에 렌더링한다.
- 이미지는 지금 S3와 클라우드프론트로 세팅
- 엣지 함수를 설정하면 한달에 2만원 정도, 더 들 수도 있다.
- Intersection Observer로 각 요소가 화면에 보여졌을 때에만 이미지 렌더링
  - 이미지가 완전히 로드되었을 때 visibility를 변경
- 캐시 설정
  - Remix Header에서 직접 캐시 설정을 할 수 있었다.
  - `must-revalidate`로 `max-age` 시간이 지나면 새로 데이터를 받아올 수 있게 했다.
  - 프론트엔드는 Cloudflare DNS Proxy가 적용되어있어서 공유되는 캐시의 유효 기간까지 설정할 수 있도록 `s-max-age`도 적용
    - DDOS 공격을 방어하기 위해 프론트엔드는 DNS Proxy 설정
    - 백엔드는 정해진 아이피, 같은 도메인으로만 접속 가능하도록 CORS
    - 실 방문자 수는 0명인데, 트래픽은 많이 찍힌다.

개인 프로젝트 이유

- 영어 스터디를 하는데 속담이나 비유법을 이해하지 못하는 경우가 종종 있었고, 곧 까먹어버리게 됨

협업

- Web3 프로젝트 초반에 레버리지, 증거금 계산기 직접 실행시켜보고 계산이 잘 안되는 경우 컨트랙트 개발자에게 질문
- 스터디 지속적으로 참석
- 메시지만 보내는 것보다는 직접 음성 채널 방에 접속해서 기다린다.
- 코드 리뷰 받는 걸 두려워하지 않음. 발전의 기회
- 웹 프론트엔드에서 큰 오류가 발생하면 주말에도 접속하여 핫픽스 작업한 경험이 있음
- 웹 서비스 런칭 또는 패치할 때에도 대기
- SDK, 컨트랙트의 코드도 시간될 때마다 PR 확인하고 어떻게 코드가 작동하는지 확인하는 습관 들임
- SDK의 오타나 에러 등을 발견하여 이슈 제보한 적이 있음
- 나는 괜찮은데 디자이너가 이런 면에서는 디자인 적으로 좋지 않을 수 있다는 것도 알게 됨
- 기록하는 습관.
- VSCode Live Share, 화면 공유

- Resize 이벤트
- MutationObserver로 리팩토링

- getBoundingClientRect 메소드는 실행할 때마다 브라우저가 창을 재 렌더링해야함
- Intersection Observer로 리팩토링

- SEO Meta 태그를 불러올 수 없음
- Remix에서 요청이 Bot인지 아닌지에 따라 핸들러 함수를 분리
- 핸들러 함수에 메타태그를 처리하는 컴포넌트가 없었음
- Minified React 에러

NextJS를 사용하지 않는 이유

- NextJS App Router의 중요성은 이해함
- 기존 SSR은 데이터를 불러오는데 시간이 오래 걸림
- 그래서 SSR 중에는 SEO에 필요한 데이터만 가져오고 나머지 데이터는 Hooks으로 중복 요청해서 가져오도록 작업
- Server Components는 페이지 단위가 아니라 컴포넌트 단위로 SSR이 가능하다고 알고 있음
- 각 페이지에 Query Parameter가 붙어있음
- 개발자 채팅 및 블로그 보니 여러가지 이슈가 많았음
- 아직까지 큰 규모의 Nextjs 한 적이 없음
- 당근가서 하고싶다.
