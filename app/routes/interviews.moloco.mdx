## 면접 대비

**Git Flow**

- 소프트웨어 브랜치를 효율적으로 관리하기 위하여 적용, 각 개발 단계를 명확하게 구분할 수 있다. 개발 브랜치를 일관성있게 관리.
- 목적에 따라 브랜치를 분류
- Main 브랜치는 실제 배포되는 브랜치
- Feature 브랜치는 각 개발자들이 작업한 것들을 업로드하는 브랜치
- Develop 브랜치는 Feature 브랜치에서 적용된 작업사항을 통합하는 브랜치, 새로운 기능과 수정사항이 반영
- Hotfix 브랜치는 Main에서 핫픽스 사항이 있을 때 생성하는 브랜치

- 로컬 Feature 브랜치에서 Develop 브랜치에 추가 작업 사항을 적용할 때는 작업할 때 커밋을 깔끔하게 관리하기 위해 Rebase Merge
- 원격 Feature 브랜치에서 Develop 브랜치에 머지할 때는 Squash Merge. Feature 브랜치가 커밋 목록이 복잡하기 때문에 Squash로 하나의 커밋으로 묶어 Develop 브랜치에서 독자적으로 관리 가능
- Develop 브랜치에서 Main 브랜치로는 일반 Merge

**프론트엔드 성능 최적화**

- 첫째, React Window를 사용하여 리스트 가상화와 무한 스크롤을 구현했습니다. 이를 통해 많은 양의 데이터를 한 번에 렌더링하지 않고, 화면에 보이는 부분만 렌더링하여 초기 로드 시간을 크게 단축할 수 있었습니다.
- 둘째, 이미지 최적화를 위해 Lazy Loading을 도입했습니다. Intersection Observer API를 사용하여 사용자가 스크롤하여 이미지가 화면에 나타날 때만 이미지를 로드하도록 설정했습니다.
- PNG를 WEBP로 교체하여 80점대 초반으로 향상
- 셋째, Lighthouse를 활용하여 성능 점수를 분석하고, 캐시 설정과 코드 스플리팅을 통해 성능을 개선했습니다. 예를 들어, Vite의 manualChunks 코드 스플리팅 기능을 사용하여 라이브러리의 크기가 큰 경우 번들 파일을 여러 개로 나눠 번들 크기를 줄이고, 필요한 시점에만 코드를 로드하도록 했습니다.
- 이러한 최적화 기법을 통해 페이지 로딩 속도를 향상시키고, 사용자 경험을 크게 개선할 수 있었습니다.

**SEO**

- 검색 엔진 최적화(SEO)를 위해 다양한 방법을 사용할 수 있습니다.

- 첫째, 서버 사이드 렌더링(SSR)을 통해 초기 HTML을 완전하게 제공하여 검색 엔진 크롤러가 페이지 내용을 쉽게 인덱싱할 수 있도록 합니다.
- 둘째, 메타 태그를 사용하여 페이지의 제목, 설명, 키워드 등을 명확하게 지정합니다. 예를 들어, `<meta name="description" content="This is an example description">`와 같이 설정할 수 있습니다.
- 셋째, 구조화된 데이터(Structured Data)를 사용하여 검색 엔진이 페이지 내용을 더 잘 이해할 수 있도록 돕습니다. JSON-LD 형식을 사용하여 웹페이지에 추가할 수 있습니다.
- 넷째, 페이지 로딩 속도를 최적화합니다. 이를 위해 이미지 최적화, 코드 스플리팅, 캐싱 등을 활용할 수 있습니다.
- 다섯째, 모바일 최적화가 중요합니다. 반응형 디자인을 사용하여 다양한 디바이스에서 최적의 사용자 경험을 제공합니다.
- 여섯째, 내부 링크 구조를 개선하여 검색 엔진이 사이트의 모든 페이지를 쉽게 탐색할 수 있도록 합니다.
- 마지막으로, 고품질의 콘텐츠를 지속적으로 생성하고, 다른 신뢰할 수 있는 사이트로부터 백링크를 얻어 검색 엔진 랭킹을 높일 수 있습니다.

**단방향 바인딩**

- 단방향 바인딩이 개발에 유리한 이유는 데이터 흐름의 명확성과 디버깅의 용이성에 있습니다.
- 양방향 바인딩은 모델과 뷰가 상호작용하여 자동으로 동기화되기 때문에, 상태 변화의 원인을 추적하기 어렵습니다. 이는 특히 대규모 애플리케이션에서 상태 변화를 예측하고 디버깅하는 데 어려움을 초래합니다.
- 단방향 바인딩은 데이터가 항상 한 방향으로만 흐르기 때문에, 상태 변화의 경로가 명확하게 정의됩니다.
- 모든 상태 변경은 액션을 통해 발생하고, 이는 디스패처를 통해 스토어로 전달되며, 스토어가 상태를 업데이트합니다. 이 과정에서 데이터 흐름이 명확하게 정의되어 있어, 상태 변화의 원인을 쉽게 추적할 수 있습니다.
- 단방향 바인딩은 코드의 일관성과 유지보수성을 높여줍니다. 각 컴포넌트는 자신의 상태만 관리하며, 상태 변화는 중앙 집중식으로 관리되기 때문에, 코드의 복잡성을 줄이고 유지보수를 용이하게 합니다. 이러한 이유로 단방향 바인딩은 복잡한 애플리케이션에서 더욱 유리합니다.

**클로저**

- JavaScript의 클로저는 함수가 선언될 때의 렉시컬 환경(Lexical Environment)을 기억하여, 함수가 선언된 이후에도 그 환경에 접근할 수 있는 기능을 말합니다. 클로저는 변수의 범위를 유지할 수 있어, 데이터 은닉과 상태 유지를 가능하게 합니다.

**협업에서 중요한 요소**

- 제일 중요한 요소는 적극성이라고 생각합니다. 제가 무언가 의사를 전달하기 전까지는 팀원들은 제 생각을 알지 못할 것입니다. 모르는 것이 있을 때는 제가 직접 팀원에게 여쭤봄으로서 팀원도 현재 제 상황을 알고 답변을 받을 수 있습니다. 현재 상황을 설명하고, 어디까지 시도했는지 전달하고, 어떤 방법을 더 생각할 수 있을지 질문드립니다.
- 적극적으로 서로 현재 상황과 알고 모르는 것을 공유함으로서 더 나은 해결책을 찾을 수 있을 것입니다. 이때 타인의 관점에서 생각하여, 나는 알고 있는 것들도 팀원들은 모를 수 있다는 걸 항상 생각해야 합니다.
- 명확한 커뮤니케이션은 프로젝트 목표, 역할 분담, 일정 등을 명확히 전달하고, 팀원 모두가 동일한 목표를 향해 일할 수 있도록 합니다. 예를 들어, 프로젝트 회의에서 각 팀원의 역할과 책임을 명확히 정의하고, 정기적인 업데이트를 통해 진행 상황을 공유합니다.
- 상호 존중은 팀원들의 의견을 경청하고, 다양한 관점을 존중하는 태도입니다. 이는 팀원들이 자유롭게 의견을 나누고, 창의적인 아이디어를 제안할 수 있는 환경을 조성합니다. 또한, 피드백을 주고받을 때 건설적이고 긍정적인 태도를 유지하여, 팀의 협업을 강화하고, 더 나은 결과를 도출할 수 있도록 합니다.
- 서로를 신뢰하고 존중하는 분위기를 조성하여, 업무에 대한 자신감을 가지고 협력할 수 있습니다.

**새로운 라이브러리 도입**

- 최근에 진행한 개인 프로젝트에서 리액트에 서버 사이드 렌더링을 적용하기 위해 Remix 프레임워크를 선택했습니다.
- Remix 없이 리액트에 서버 사이드 렌더링을 적용할 때에는 서버 사이드 렌더링하는 코드를 직접 작성해줘야 했습니다. 컴포넌트에 렌더링하기 전 데이터를 불러오는 역할의 '로더'나 메타 정보를 표시하는 함수도 별도로 관리해야 했습니다. - Remix 프레임워크는 하나의 파일에 로더, 메타데이터, 폼 액션, 컴포넌트를 관리함으로서 생산성을 개선할 수 있습니다.
- 새로운 라이브러리 및 프레임워크를 학습하는 방법은 직접 프로젝트를 만들어보거나 기존 프로젝트의 문제점을 새로운 도구로 해결하는 것이라고 생각합니다.
- 내가 가진 문제를 해결함으로서 왜 이 도구가 필요한지 깨달을 수 있었습니다. 새로운 라이브러리를 활용할 때는 공식문서와 예제 코드를 지속적으로 참고합니다.
- 그 외에도 개발 뉴스레터 및 Hashnode 같은 개발 전문 블로그 사이트를 접속하여 개발 트렌드 및 노하우를 확인할 수 있습니다.

**HTTP 개념**

- 웹에서 데이터를 주고받기 위한 통신 프로토콜, 요청 응답
- 무상태성, 각 요청을 독립적으로 처리
- 상태 코드

- 메소드

  - GET
  - POST
  - PUT
  - PATCH: 자원 부분 수정
  - DELETE

- 헤더: 요청과 응답 메시지에 포함되어 추가 정보를 전달

- HTTP2: 멀티플렉싱, 헤더 압축, 서버 푸시
- HTTP3: QUIC 기반 전송 속도를 향상

**Hydration**

- Render: 서버에서 리액트 컴포넌트를 HTML로 변환하여 클라이언트에 전송
- 초기 페이지 로드 시간 단축 및 검색 엔진 최적화
- 브라우저가 HTML을 받아 렌더링

- Rerendering: 상태가 변경될 때 컴포넌트가 업데이트되는 것

- Hydration: 리액트 이벤트 핸들러와 상태 추가하여 애플리케이션으로서 동작하도록 하는 작업. 기존 HTML을 재사용. 초기 렌더링에서만 사용

**HTTP 버전 차이**

- 1.1: 연결을 재사용하여 여러 요청과 응답 처리. 오버헤드 감소, 요청 헤더에 호스트 정보 포함하여 하나의 IP 주소에서 여러 도메인 호스팅, 캐싱, 콘텐츠 협상
- 2: 바이너리 형태로 데이터 전송. 하나의 TCP 연결로 여러 요청과 응답을 동시에 처리. 헤더 압축, 페이지 로드 속도 향상, 멀티플렉싱
- 3: QUIC은 UDP 위에서 동작하여 TCP의 혼잡 제어를 포함하면서도 더 빠른 연결과 데이터 전송. 첫번째 데이터 패킷에 암호화와 인증정보 포함하여 0-RTT 연결 설정. TLS로 데이터 전송 보안

**REST**

- 특징
  - 자원: 고유한 URI로 구분
  - 표현: 포맷
  - 메소드: HTTP 메소드
  - 계층화하여 클라이언트에서는 중간 계층을 통해 접근

**TCP UDP**

- TCP: 연결 지향적, 신뢰성 보장, 흐름 혼잡 제어, HTTP이 TCP 위에서 작동, 전송 계층 프로토콜, IP와 함께 데이터 전송 담당
- UDP: 비연결 지향적, 무결성 보장하지 않음. 간단한 헤더 구조

  - 단점: 신뢰성 부족, 순서 보장 없음

- QUIC: TCP 신뢰성과 TLS 보안 적용,

**로컬 스토리지와 쿠키**

- 로컬 스토리지: 데이터를 키-값 쌍으로 저장. 쿠키보다 더 큰 데이터, 만료되지 않음, HTTP에 의해 자동으로 전송되지 않음

  - 사용처: 대용량 데이터, 오프라인 웹 애플리케이션에서 데이터 저장

- 쿠키: 클라이언트와 서버 간의 상태를 저장하기 위해 사용하는 데이터. HTTP 요청에 의해 자동 전송, 만료 시간. 중요한 정보는 HttpOnly로 자바스크립트로 접근 불가능하도록 설정, Secure로 HTTPS에서만 전송
  - 사용처: 세션 관리, 사용자 광고 타겟팅

**SSL/TLS**

- 브라우저가 서버에 연결을 보냈을 때 브라우저가 지원하는 SSL 버전, 암호화 방식, 무작위 데이터 포함됨
- 서버가 선택한 SSL 버전, 암호화 방식
- 서버는 자신의 인증서를 브라우저에 전송. 서버의 신원 증명, CA에 의해 발급됐는지 확인
- 브라우저는 서버 공개키로 대칭 키를 암호화 및 서버에 전송.

**Remix의 경로 분할**

- Remix는 경로 분할(route splitting)을 통해 각 경로마다 필요한 자원만을 로드하는 기능을 제공합니다. 이를 통해 병행 로딩이 가능해져, 사용자에게 더 빠르고 부드러운 경험을 제공합니다.

- 코드 스플리팅: 경로별로 필요한 자원을 분리하여, 초기 로딩 시 모든 코드를 로드할 필요가 없습니다. 이는 초기 로딩 시간을 줄이고, 네트워크 트래픽을 최적화합니다.
- 병행 로딩: 경로별로 필요한 자원을 병행으로 로드하여, 전체 로딩 시간을 단축시킵니다. 이는 특히 대규모 애플리케이션에서 중요한 성능 최적화 기술입니다.
- 로더와 액션의 분리: Remix는 각 경로별로 데이터를 로드하는 로더(loader)와 사용자 액션을 처리하는 액션(action)을 분리하여, 데이터를 병행으로 로드하고 사용자 요청을 효율적으로 처리할 수 있게 합니다.

**프론트엔드의 Solid**

- 단일 책임 원칙: 컴포넌트는 하나의 책임만 가져야 합니다. 예를 들어, 데이터를 가져오는 로직과 UI 렌더링 로직을 분리하여, 한 컴포넌트는 데이터를 가져오는 역할만 하고, 다른 컴포넌트는 그 데이터를 받아서 렌더링하는 역할을 합니다. 이렇게 하면 코드의 가독성과 유지보수성이 향상됩니다.
- 예: 데이터 가져오는 Hook, 데이터와 상태를 기반으로 재계산하는 Hook, UI 컴포넌트로 분리할 수 있다.

- 개방 폐쇄 원칙: 컴포넌트는 확장에는 열려 있어야 하지만, 수정에는 닫혀 있어야 합니다. 예를 들어, 새로운 기능을 추가할 때 기존 코드를 수정하지 않고 확장할 수 있도록 컴포넌트를 설계합니다. 이를 위해 HOC(고차 컴포넌트)나 렌더 프롭스를 사용할 수 있습니다.
- 예: 모달 컴포넌트를 설계할 때는 처음에는 Props에 title, textContent, imageContent, button 등의 많은 항목을 계속해서 추가했으나, 지금은 children Props을 통해 Props를 수정하지 않고 컴포넌트를 유동적으로 렌더링할 수 있다.

- 리스코프 치환: 서브클래스나 컴포넌트는 언제나 자신의 기반 클래스나 컴포넌트와 호환되어야 합니다. 이는 상속 관계에서 클래스 간의 일관성을 유지하고, 컴포넌트를 교체해도 기능이 정상적으로 작동할 수 있게 합니다. 예를 들어, 공통 인터페이스를 구현하여 다양한 컴포넌트를 교체 가능하게 만듭니다.
- 예: 입력 컴포넌트를 Generic 프로그래밍을 통해 상태의 타입이 String, Number, Bigint로 교체되더라도 호환되도록 리팩토링.

- 인터페이스 분리: 클라이언트가 사용하지 않는 메서드에 의존하지 않도록 인터페이스를 분리합니다. 리액트에서는 컴포넌트가 불필요한 props를 받지 않도록 설계하는 것이 중요합니다. 예를 들어, 여러 개의 작은 인터페이스를 만들어 필요한 부분만 구현하도록 합니다.
- 예: 방대한 페이지 컴포넌트를 여러 개의 UI 컴포넌트로 분리

- 의존성 역전: 고수준 모듈이 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다. 이는 컴포넌트 간의 결합도를 낮추고, 테스트와 유지보수를 용이하게 합니다. 리액트에서는 컨텍스트 API나 DI(의존성 주입) 패턴을 사용하여 의존성을 주입할 수 있습니다.
- 예: 다크 모드를 스위치할 수 있는 컴포넌트가 있을 때 스위치 컴포넌트까지 props을 전달하는 것이 아닌 Context API를 통해 스위치 컴포넌트가 다른 컴포넌트로 대체되도 다크모드 스위칭이 가능하도록 한다.

**Svelte의 최적화**

- 컴파일 시 최적화된 자바스크립트 파일을 생성한다. 최소한의 DOM 조작을 수행하기 때문에 퍼포먼스를 보장할 수 있다.

- React의 Virtual DOM은 다양한 플랫폼에서 채택될 수 있다.
- React는 서버 사이드 렌더링을 할 수 있는 자체 API를 제공한다.

**Vite로 빌드 후 에셋 파일에 해쉬 값이 생성되는 이유**

- Vite에서 프로젝트를 빌드하면 에셋 파일에 해쉬 값을 작성하는 이유는 캐시 무효화를 위해서입니다. 웹 브라우저는 성능을 최적화하기 위해 정적 파일(CSS, JS, 이미지 등)을 캐싱합니다. 그러나 파일이 업데이트되었음에도 불구하고 브라우저가 이전 버전을 캐싱하고 있으면 최신 변경 사항이 사용자에게 반영되지 않는 문제가 발생할 수 있습니다.
- 이를 방지하기 위해 Vite는 빌드 과정에서 각 에셋 파일 이름에 고유한 해쉬 값을 추가합니다. 예를 들어, index.js 파일이 index.8d7f8d.js와 같이 변경됩니다.
- 해쉬 값은 파일 내용이 변경될 때마다 새로 생성되기 때문에, 파일이 업데이트될 때마다 파일 이름이 달라지게 됩니다.
- 브라우저는 새로운 파일 이름을 인식하고, 이전에 캐싱된 파일이 아닌 최신 파일을 요청하게 됩니다. 이 과정은 캐시 무효화를 통해 사용자에게 항상 최신 버전의 파일을 제공하여, 변경 사항이 즉시 반영되도록 보장합니다.

**배포 후 이슈**

- Suspense가 적용된 경우 새 배포 후 접속하면 페이지 이동했을 때 에러가 발생한다.
- index.html 파일이 브라우저에 캐시되어 있어도 타 페이지에서 불러올 모듈이 서버에 없으면 에러가 발생
- 서비스 워커 도입으로 해결, 새 배포되면 브라우저 알림

**백엔드 언어로 Go?**

- 언어의 문법이 적어서 배우기 쉬웠음
- 컴파일하면 실행 가능한 바이너리 파일이라 PM2 같은 추가적인 프로그램이 필요하지 않음. 서버에 낮은 부담

**CDN?**

- S3에 있는 이미지를 웹 페이지에 렌더링하지 않고 Cloudfront에서 캐싱
- S3 버킷을 직접 읽지 않고 캐시된 이미지를 사용하여 S3의 부담 감소
- S3에 직접적인 접근을 차단
- 버킷이 사용자와 거리가 먼 경우 클라우드프론트로 가까운 캐시 서버에서 데이터 제공

**유지보수성**

- 첫째, 모듈화를 중요하게 생각합니다. 코드를 작고 독립적인 모듈로 분리하여 각각의 모듈이 하나의 책임만 가지도록 합니다. 예를 들어, Chromatic Protocol 프로젝트에서 각 기능을 독립적인 컴포넌트로 분리하고, 필요에 따라 재사용할 수 있도록 설계했습니다.
- 둘째, 주석과 문서화를 통해 코드의 의도와 동작을 명확하게 기록합니다.
- 마지막으로, 코드 리뷰를 통해 코드 품질을 지속적으로 개선하고, 팀원들과의 협업을 통해 최선의 코딩 방식을 유지하고 있습니다.

- 추가: Hooks을 작성할 때 API 데이터를 불러오는 Hooks과 데이터를 계산하는 Hooks를 분리하여 데이터를 계산하는 Hooks을 테스트할 수 있었습니다. 보통 함수를 분리할 때는 API 같은 외부 요소와 상호작용하는 액션과 데이터를 기반으로 새로운 값을 도출하는 계산으로 분리한다. API 호출은 네트워크 오류 등으로 데이터를 보장할 수 없고, 계산 부분을 분리해야 테스트하기 원활해진다. 어디에서 원인이 발생했는지 알 수 있었다.

**Observer**

- 마지막으로 설정한 Textarea의 크기를 로컬 스토리지에 기록하기 위해 getBoundingClientRect를 호출하면 브라우저가 Textarea 및 하위 요소를 다시 reflow합니다. MutationObserver를 채택하면 재렌더링없이 크기를 가져올 수 있다.
- Textarea의 크기를 로컬 스토리지에 저장하기 위해 크기가 바뀔 때마다 계속 저장했다. 요소의 길이와 높이를 읽는 과정에서 reflow가 계속 발생할 수 있어서 Document의 beforeunload 이벤트를 받아서 페이지가 닫힐 때에만 높이를 가져다 저장하고 재접속시 재사용한다.

**캐시 방법**

- Remix의 응답 헤더 캐시
- Cloudflare의 캐시 설정
- 새 배포 후 Purge

**캐시 무효화**

- 빌드할 때 해쉬 값 생성
- 타임스탬프
- 서비스 워커
- 파일에 버전

**React 프로젝트는 어떤 패턴을 사용해야 하는가**

- MVVM 패턴

- 컴포넌트가 뷰의 역할을 한다. 모델의 역할은 API 호출로 받은 데이터이다.

- 리액트 Hooks가 뷰모델 역할을 할 수 있다. 뷰모델 내에서 컴포넌트 상태를 정의하고 어떻게 상태를 업데이트할지, 상태를 기반으로 데이터를 어떻게 계산할지 결정함으로써 뷰와 모델 간 데이터를 바인딩한다.

- 뷰는 뷰모델에서 업데이트한 변수를 기반으로 UI를 적용시키는 역할만 수행한다.

- Flux 패턴은 Redux 및 Context API 전역 상태를 관리할 때 사용될 수 있을 것이다. 전체적인 스토어에서 하위 컴포넌트로 데이터를 전달하는 방식이기 때문이다.

## 내 질문

기본

- 동영상 맥락분석 AI를 어떻게 매출로 연결시키는지 알고 싶습니다.
- 유튜브 동영상의 경우 문제가 있는 동영상의 광고를 송출하지 못하게 하려면 유튜브에 개입을 하는 방식인가요?
- 개발 팀의 규모는 어떻게 되나요. 제가 모든 걸 주도해야 하나요?
- 스터디를 할 수 있는 환경인가요?
- 작업 배정은 어떻게 하나요?
- NextJS는 앱 라우터의 경우, 개발할 때 발생하는 이슈에 대해 잘 정리가 되어있나요?
- 프론트엔드라면 정확히 AiD 대시보드 외에도 개발하는 프로젝트가 더 있을까요?
- 스탠딩 책상이 있나요?
- 점심식사비와 저녁식사는 연봉에서 차감하는 방식인가요?

- 더 수준 높은 프론트엔드가 아닌 2년차의 프론트엔드 개발직을 채용하는 이유가 무엇인가요?
- 코드 리뷰 시스템은 어떻게 운영되고 있나요?
- 협업은 주로 어떻게 구성되어 있나요?
- 현재 그루우의 최우선 목표는 무엇인가요?
- PC 웹 버전도 개발할 계획이 있을까요? 없다면 프론트엔드 개발자가 추후에 모바일 앱 개발에도 참여할 수 있을까요? 리액트 네이티브를 하면서 어떤 이슈를 맞이했으며 어떻게 해결했는지 알 수 있을까요?
- 브랜치 관리 및 배포 프로세스는 어떻게 되나요?
- 식물을 키우는 공간, 환경 조건, 건강 상태 등을 주관적인 데이터를 수치화하는 방법은 무엇일까요?
- CEO도 강의를 수강한다고 했는데 강의를 선택하는 기준?

회사 목표와 비전

- 회사의 장기적인 목표는 무엇인가요? 그리고 이를 달성하기 위해 어떤 전략을 사용하고 계신가요?
- 앞으로 5년 내에 회사가 도달하고 싶은 비전은 무엇인가요? 그리고 이를 실현하기 위해 현재 어떤 노력을 기울이고 있나요?
- 현재 회사가 가장 집중하고 있는 주요 목표는 무엇인가요? 이 목표를 달성하기 위한 주요 도전 과제는 무엇인가요?

팀 문화와 작업 방식

- 이 팀은 어떤 가치와 문화를 중요시하나요? 이러한 가치와 문화는 일상 업무에서 어떻게 실천되고 있나요?
- 팀 내에서 협업과 의사소통은 어떻게 이루어지나요? 구체적인 사례를 들어 설명해 주실 수 있나요?
- 최근 팀이 직면했던 주요 문제는 무엇이었고, 이를 어떻게 해결하셨나요? 이 과정에서 가장 중요한 교훈은 무엇이었나요?
- 팀원 간의 피드백 프로세스는 어떤 형태로 이루어지나요? 피드백을 효과적으로 주고받기 위해 어떤 방법을 사용하고 있나요?

회사 프로젝트와 성과

- 최근 회사가 성공적으로 완료한 프로젝트는 무엇인가요? 이 프로젝트가 회사에 어떤 영향을 미쳤나요? 공식 홈페이지에서 앱을 첫 빌드한 것을 확인했습니다.
- 이러한 프로젝트를 통해 배운 것 중 가장 중요한 것은 무엇인가요? 이 교훈을 어떻게 향후 프로젝트에 적용하고 있나요?
- 현재 진행 중인 주요 프로젝트는 무엇이며, 이 프로젝트가 회사에 끼칠 영향은 무엇인가요? 이 프로젝트에서 제가 맡게 될 역할은 무엇일까요?

직원 성장과 발전 기회

- 회사는 직원의 성장을 위해 어떤 교육 프로그램이나 지원을 제공하나요? 이러한 프로그램이 실제로 어떻게 운영되고 있나요?
- 직무 연계 교육 외에 직원들이 성장할 수 있는 기회는 무엇인가요? 예를 들어, 회사에서 제공하는 멘토링 프로그램이나 자율 학습 기회가 있나요?
- 회사 내에서 커리어 발전의 기회는 어떻게 주어지나요? 승진이나 직무 변경 등의 기회가 주어지는 과정에 대해 설명해 주실 수 있나요?

회사 문화와 가치

- 회사가 자랑스러워하는 문화적 요소는 무엇인가요? 이러한 문화가 직원들에게 어떤 긍정적인 영향을 미치고 있나요?
- 회사가 중요하게 생각하는 핵심 가치는 무엇인가요? 이러한 가치를 직원들이 일상 업무에서 실천할 수 있도록 어떤 노력을 기울이고 있나요?
- 회사의 가치를 일상 업무에서 어떻게 실천하고 있나요? 구체적인 사례를 들어 설명해 주실 수 있나요?

## 문화

**만들어가고 싶은 회사 문화**

- 협력
- 기술의 변화가 빠르기 때문에 팀원과의 협업이 중요함. 이슈를 빠르게 해결하고 다양한 관점을 반영하여 서비스를 지속적으로 개선한다.
- 내가 먼저 의견을 제시함으로서 서비스 개선에 기여할 것이다.
- 새로운 라이브러리나 개발 방식을 학습하고 공유할 것이다.
- 올바른 코드 리뷰
- 전 직장에서는 코드 리뷰를 하려고 해도 기본적인 기능만 작동하는지, 당장 발견할 수 있는 에러는 없는지만 확인했다. 코드에 어떤 잠재적 문제가 있는지, 어떻게 개선할 수 있는지 판단하기 힘들었다.
- 상호 간에 고품질의 코드 리뷰를 통해 지속적으로 서비스 개선하고 싶다.
- 필요하다면 AI 서비스의 도움을 받는 방법도 있을 것 같았다.
- **개발 몰입의 경험**

- 전체적인 리팩토링
- Suspense, lazy를 도입하여 코드 스플리팅 및 네트워크 최적화
- 프로젝트 전반적으로 리팩토링이 필요함
- 그럼에도 번들되는 파일 사이즈가 커서 Vite에서 번들 크기를 절약하는 방법을 계속 찾아봄
- 주말에도 학습
- manualChunks로 용량이 높은 노드 모듈의 경우 추가적으로 스플리팅하여 파일의 용량을 감소하여 로딩 시간 단축, 외부에서 내려받은 노드 모듈을 modulepreload로 불러오기 때문이다. modulepreload는 브라우저가 미리 모듈을 파싱 및 컴파일하여 타 모듈에 의해 실행될 수 있게 구성해놓는다.
- Suspense, lazy를 적용하면 SSR할 때 renderToString을 못 써서 renderToPipableStream으로 리팩토링
- 초기 로딩 시간 단축, 네트워크 요청 횟수 절약, 소통의 중요성을 알게 됨
- 프론트엔드를 새로 배포하면 페이지 이동할 때 Failed to dynamically module 에러가 발생한다.
- 웹 브라우저에는 기존 캐시된 모듈 파일이 남아있는데 모듈 파일이 가리키는 모듈을 번들 파일에서 찾을 수 없어서 발생하는 에러
- Service Worker를 도입하여 모듈 파일을 캐시하도록 했다. 새 배포가 확인되면 새로고침을 유도할 수 있는 토스트 UI 표시
- 스토리북으로 UI 테스트할 때 API 또는 Props와 연결된 컴포넌트는 테스트하기 힘들었다. 예를 들어 상태가 Props에 의해 결정되는 경우 스토리 파일 만으로는 상태 변경을 재현하기 힘듦

**지원 동기**

- 저도 식물을 키운 경험이 있다.
- 인터넷이나 책에서 따라해도 서로 환경이 달라 예상하지 않은 결과를 맞는 경우도 있었다.
- 대표적으로 원룸은 빛이 잘 들어오지 않아 식물이 잘 자라지 않는다.
- 식물을 키우는 것은 사람들의 삶에 긍정적인 영향을 줄 수 있다.
- 그 과정에서 겪는 어려움을 IT 기술로 해결하는 점
- 프론트엔드 및 모바일 앱 개발에도 기여하고 싶다.
- 나아가 더 나은 디자인을 구성하는데에도 기여하고 싶다. 프로젝트 관리 능력도 키우고 싶다. 커뮤니케이션 스킬, 코드 리뷰 경험
- 지속적으로 학습 및 도전

**직무 수행 방식**

- 프론트엔드 개발자로서 데일리 스크럼을 진행했다.
- 데일리 스크럼을 함으로서 당일 무슨 작업을 할지 서로 커뮤니케이션하고 빠른 피드백이 가능했다.
- 사용자 요구사항에 빠르게 대응할 수 있었다.
- 개발에 집중하다보니 컴포넌트 및 Hooks의 구조가 문제가 있어도 개선할 수 없었다.
- 지속적인 코드 리뷰로 컴포넌트의 품질을 개선하려고 했으나 시간이 부족했다.
- 스크럼의 횟수를 주 3회 정도로 줄임과 동시에 코드 리뷰에 시간을 좀 더 투자한다. 코드 리뷰는 AI 서비스의 도움을 받을 수 있을 것 같았다.
- 브랜치 관리
- 로컬에서 개발한 것에 대한 브랜치는 Feature, 작업 사항들이 모인 브랜치는 Develop, 배포 브랜치는 두 브랜치로 관리됨
- 배포 브랜치를 두 개 이상으로 관리할 때 Git Flow 전략을 어떻게 수립해야 할지 헷갈리는 경우가 많았음
- Main1 에서 Main2인지, 아니면 각각 Main1 Main2인지, 그럼 각 배포에서만 보여져야 하는 UI는 어떻게 관리하는지
- Dev 브랜치를 fetch할 때도 rebase 하는지, squash merge 하는지 차이가 있었다.
- Git Flow 전략을 초기에 잘 마련한 다음 프로젝트를 진행했으면 어떨까 싶었다.

**역할**

- 프론트엔드 개발자
- 지속적으로 사용자의 요구사항 반영
- 프로젝트 구조 개선할 수 있는 방법을 계속 고민

- 어떤 UI가 좋은 UI인지 개발하면서 찾아나가겠다.

**역량**

- 프론트엔드 개발
- 백엔드 팀원과 협업하여 문제 해결
- 디자이너 팀원과 협업하여 디자인 및 사용자 경험 개선
- 이슈 기반으로 주도적으로 문제 해결
- 지속적인 리팩토링

**채우고 싶은 역량**

- 디자인 시스템 설계 능력
- 공통 컴포넌트를 설계할 때 Props을 어떻게 부여할 것인지, 특이 케이스는 어떻게 대응할지 알고 싶다.
- 이전에는 공통 컴포넌트에 Props를 계속 추가해서 컴포넌트 내에서 계속 분기 처리를 해줘야 했다.
- Props를 추가할 때마다 예상하지 못한 사이드 이펙트가 발생한다.
- 공통 컴포넌트를 잘 설계하는 방법을 익히고 싶다.

- 모바일 앱 개발 능력, 네이티브 지식
- 웹 개발 지식을 모바일 앱에 사용할 수 있으나 제한점이 많음
- React Native와 네이티브 지식을 학습함으로서 그루우 앱에 기여하여 모바일 앱 개발 능력도 키우고 싶다.
- 추후에는 모바일과 웹을 전부 포함하는 디자인을 구성할 수 있는 능력을 향상시키고 싶다.
- 개발 관점에서만 사용자 경험이 아닌 디자인 관점에서 사용자 인터페이스 개선 능력도 키우고 싶다.

- 커머스 개발 역량
- 아직 커머스 웹을 개발해 본 적이 없다.
- 커머스 앱에 기여함으로서 지속적으로 운영 가능한 커머스 웹을 어떻게 구성되어야 하는지 확인하고 싶다.

- 새로운 솔루션 제시
- 프로젝트가 어떻게 나아가야 할지 새로운 솔루션을 제안하기 힘들었다.
- 기존 프로젝트의 이슈를 해결하는 건 문제가 없었다.
- 사람들이 필요로 하는 새로운 기능을 어떻게 생각하는지 알아내는 방법을 학습해야겠다는 생각을 했다. 사람들이 요구하는 사항을 어떻게 코드로서 구현할 수 있을지 지속적으로 학습하고 싶다.
