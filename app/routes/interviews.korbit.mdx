# Korbit 면접

## 개발자가 되려는 이유

사용자에게 실질적인 도움을 주는 어플리케이션을 개발하는 데 큰 보람을 느끼기 때문입니다. 프론트엔드 개발자로서 사용자가 인터페이스와 직접 상호작용하는 부분을 개발하며, 사용자 경험을 최적화하는 것이 저에게 큰 동기부여가 됩니다.

사용자 중심의 개발 철학을 숙지하려고 하며, 사용자에게 가치를 제공하는 것이 개발자로서의 가장 큰 동기입니다. 따라서, 저는 개발자로서 사용자의 불편함과 필요를 이해하고, 이를 해결하는 서비스를 제공하는 목표를 가지고 있습니다.

## Web3 특징

- 블록체인 스마트 컨트랙트와 상호작용
- 사용자가 트랜잭션을 요청하거나 컨트랙트를 조회하기 위해 라이브러리를 사용해야 한다.
- 컨트랙트에 트랜잭션을 제출하면 처리되기까지 시간이 걸린다.

  - 새로운 트랜잭션이 발생하면 블록체인의 여러 노드가 해당 트랜잭션을 검증한다.
  - 블록체인 네트워크의 노드가 트랜잭션을 받을 때마다 서명이 유효한지 판단한다.
  - 트랜잭션으로부터 블록이 생성되어 합의 알고리즘을 거쳐 블록이 체인에 추가된다.
  - 추가 블록을 쌓아 안전성을 유지한다.
  - 프론트엔드로 전파

- ChatGPT로 얻은 트랜잭션 과정

  1. 사용자가 트랜잭션을 생성합니다. 이 트랜잭션은 전송자, 수신자, 금액, 트랜잭션 수수료 등의 정보를 포함합니다. 트랜잭션은 사용자의 개인 키로 디지털 서명되어 네트워크로 전송됩니다.
  2. 트랜잭션 전파 서명된 트랜잭션은 네트워크의 노드에 전파됩니다. 각 노드는 트랜잭션의 유효성을 검증합니다. 검증된 트랜잭션은 메모리 풀에 저장됩니다.
  3. 메모리 풀에서 트랜잭션 대기 메모리 풀은 블록에 포함되지 않은 유효한 트랜잭션이 대기하는 공간입니다. 여기에서 트랜잭션은 채굴자가 선택할 때까지 대기합니다. 트랜잭션 수수료가 높은 트랜잭션이 우선적으로 선택됩니다.
  4. 채굴자 트랜잭션 선택 채굴자는 메모리 풀에서 트랜잭션을 선택합니다. 채굴자는 일반적으로 수수료가 높은 트랜잭션을 우선적으로 선택하여 보상을 극대화합니다. 여러 트랜잭션을 선택하여 블록을 구성합니다.
  5. 블록 헤더 생성 채굴자는 선택한 트랜잭션을 포함하여 블록 헤더를 생성합니다. 블록 헤더에는 이전 블록의 해시, 타임스탬프, 논스, 머클 루트 등이 포함됩니다. 머클 루트는 블록 내 모든 트랜잭션의 해시를 포함한 트리 구조의 최상위 해시입니다.
  6. 논스 값 찾기 채굴자는 블록 해시가 특정 조건을 만족할 때까지 논스 값을 변경하며 해시를 계산합니다. 이 과정은 매우 많은 계산 자원을 요구합니다. 목표 해시값을 찾는 과정을 통해 블록을 성공적으로 채굴합니다.
  7. 블록 생성 논스 값을 찾은 후, 채굴자는 새로운 블록을 생성합니다. 생성된 블록에는 선택된 트랜잭션과 블록 헤더 정보가 포함됩니다. 채굴자는 이 블록을 네트워크에 전파합니다.
  8. 블록 전파 새로운 블록은 네트워크의 모든 노드에 전파됩니다. 각 노드는 블록의 유효성을 검증합니다. 검증된 블록은 노드의 로컬 블록체인에 추가됩니다.
  9. 블록 검증 각 노드는 블록 내 모든 트랜잭션이 유효한지 확인합니다. 블록 해시와 블록 헤더 정보의 무결성을 검증합니다. 블록이 유효하면 노드의 블록체인에 블록을 추가합니다.

- `lazy`가 컴포넌트를 언제 가져오는지
  - 최초 컴포넌트를 렌더링하기까지 대기하기 위해 동적 임포트로 컴포넌트를 불러오는 함수를 작성해야 한다.
  - 렌더링이 필요할 경우 렌더링이 끝나기까지 Suspense 등으로 대체 컴포넌트를 보여줘야 한다.

## 프론트엔드 개발하는 이유

개발자로서 우리가 개발한 어플리케이션이 유저들에게 도움을 주는 것을 볼 때마다 보람을 느낍니다.

굳이 백엔드가 아니더라도, URL 인코딩, 코드에 색상을 입혀주는 사이트, BASE64, 사진에서 색상을 추출하는 웹 사이트, Mp4를 Webp등으로 컨버팅해주는 사이트... (이건 백엔드가 있었음..), 공식문서

사용자로부터 제보되는 이슈, 그리고 QA 및 디자인 담당 팀원으로부터 피드백을 적극적으로 반영하여 사용자에게 더 친화적인 프론트엔드를 개발하는 방법을 계속 생각해왔습니다.

웹 애플리케이션의 프론트엔드를 개발함으로서 우리가 개발하는 서비스로 유저들이 각자의 문제점을 해결할 수 있도록 필요한 작업을 진행했습니다.

## 프론트엔드를 개발하면서 중요하게 생각하는 원칙

사용자 중심의 설계와 프로젝트의 유지보수성입니다. 사용자 경험을 최우선으로 고려하여 직관적이고 반응성이 뛰어난 인터페이스를 제공하는 것을 목표로 합니다. 또한, 코드는 항상 가독성과 유지보수성을 염두에 두고 작성해야 합니다. 이를 위해 모듈화, 컴포넌트 기반 아키텍처, 철저한 테스트를 중요하게 생각합니다. 이러한 원칙을 통해 사용자에게 최상의 경험을 제공하고, 개발 팀의 생산성을 높일 수 있습니다.

## PoW와 PoS

PoW와 PoS는 블록체인의 합의 알고리즘으로, 각각 다른 방식으로 블록 생성과 트랜잭션 검증을 처리합니다.
PoW는 작업 증명을 요구하며, 마이너가 복잡한 수학 문제를 해결하여 블록을 생성합니다. 이는 높은 보안을 제공하지만, 막대한 에너지 소비와 느린 트랜잭션 속도가 단점입니다. 비트코인과 초기 이더리움이 PoW를 사용합니다.
PoS는 자산 증명을 기반으로 하며, 블록 생성자가 자신의 지분을 바탕으로 선택됩니다. 이는 에너지 효율이 높고 트랜잭션 속도가 빠르지만, 초기 자산 분배의 불공정성과 중앙화 우려가 단점입니다. 이더리움 2.0은 PoS로 전환을 계획하고 있습니다. PoW는 높은 보안이 필요한 네트워크에 적합하고, PoS는 에너지 효율과 확장성을 중시하는 네트워크에 적합합니다.

## 협업

- 컨트랙트 개발 팀원과 주기적인 협업
- 사용자가 투자 포지션을 진입할 때 사용자가 입력한 증거금, 레버리지, 유동성에 대해 예상 수수료와 포지션에서 최종 사용 금액을 계산하는 공식을 컨트랙트 개발자가 작성
- 파이썬 코드를 실행시켜보고, 프론트엔드 개발할 때도 나타나는 UI가 공식과 맞는지 컨트랙트 개발 팀원과 점검
- 예상 수수료를 계산 식을 점검하여 화면에 보여지는 예상 수수료를 90% 감소.
- 메타마스크에서 계산해주는 가스비로는 트랜잭션이 체결이 안되는 문제가 있었다. 컨트랙트 개발 팀원과 협업하여 최소 가스비 점검

## PoS

블록 생성자의 선택: PoS 시스템에서는 블록 생성자가 이미 보유한 스테이킹 또는 암호화폐의 양에 따라 무작위로 선택됩니다. 시스템에 의해 선택된 블록 생성자가 다음 블록을 생성할 권한을 가지게 됩니다.
트랜잭션 수수료: PoS에서도 트랜잭션 수수료는 중요한 요소입니다. 블록 생성자는 일반적으로 수수료가 높은 트랜잭션을 우선적으로 포함합니다. 이는 PoS 블록 생성자도 수익을 극대화하려는 동기가 있기 때문입니다.
트랜잭션의 유효성: 블록 생성자는 트랜잭션의 유효성을 검증합니다. 이 과정에서 트랜잭션이 올바른지, 이중 지불(double spending)이 없는지 확인합니다. 유효하지 않은 트랜잭션은 블록에 포함되지 않습니다.
네트워크 정책 및 규칙: 각 블록체인 네트워크는 트랜잭션 선택에 대한 특정 정책과 규칙을 가질 수 있습니다. 예를 들어, 특정 트랜잭션 유형이나 우선순위가 정의될 수 있습니다. 블록 생성자는 이러한 규칙을 준수하여 트랜잭션을 선택해야 합니다.
트랜잭션 크기 및 블록 크기 제한: 블록 생성자는 블록 크기 제한 내에서 최대한 많은 트랜잭션을 포함하려고 합니다. 이는 네트워크의 블록 크기 제한에 따라 달라질 수 있습니다. 따라서, 블록 생성자는 트랜잭션의 크기를 고려하여 블록을 최적화합니다.
네트워크 상태: 네트워크의 현재 상태나 혼잡도에 따라 트랜잭션 선택 기준이 달라질 수 있습니다. 예를 들어, 네트워크가 혼잡한 경우 수수료가 높은 트랜잭션이 우선적으로 처리될 가능성이 높습니다.
우선순위 트랜잭션: 일부 네트워크에서는 특정 트랜잭션이 우선순위를 가질 수 있습니다. 예를 들어, 특정 스마트 컨트랙트와 관련된 트랜잭션이나 특정 사용자 그룹의 트랜잭션이 우선적으로 처리될 수 있습니다.

## 개발자로서의 장점

저의 첫 번째 장점은 문제 해결 능력입니다. 프로젝트를 진행하면서 복잡한 기술적 문제를 해결한 경험이 많습니다. 예를 들어, Chromatic Protocol 프로젝트에서 네트워크 요청 최적화 문제를 해결하기 위해 SWR과 React Suspense를 사용하여 네트워크 부하를 줄이고 사용자 경험을 향상시킨 사례가 있습니다. 이러한 문제 해결 능력은 다양한 프로젝트에서 유용하게 활용되었습니다.

두 번째로, 협업 능력이 뛰어납니다. Quarkonix에서 백엔드 및 컨트랙트 개발 팀원들과 긴밀히 협력하여 프로젝트를 성공적으로 완료한 경험이 있습니다. 주기적인 회의를 통해 진행 상황을 공유하고, 발생하는 문제를 팀원들과 함께 해결해 나갔습니다. 이러한 협업 능력은 팀 프로젝트의 성공에 중요한 요소라고 생각합니다.

세 번째로, 프론트엔드 성능 최적화에 대한 깊은 이해를 가지고 있습니다. useidioms.com 프로젝트에서는 React Window를 사용하여 리스트 가상화와 무한 스크롤을 구현하여 성능을 크게 향상시켰습니다. 또한, 이미지 최적화와 캐시 설정을 통해 페이지 로딩 시간을 줄이는 등 다양한 성능 최적화 기법을 적용해 왔습니다.

네 번째로, 최신 기술에 대한 지속적인 학습이 저의 강점입니다. TypeScript, React, SWR, Remix와 같은 최신 기술 스택을 사용하여 프로젝트를 진행해 왔으며, 새로운 기술을 빠르게 습득하고 적용하는 능력을 갖추고 있습니다. 이는 급변하는 기술 환경에서 중요한 능력이라고 생각합니다.

마지막으로, 사용자 중심의 개발 철학을 가지고 있습니다. 사용자 경험을 최우선으로 고려하여 직관적이고 반응성이 뛰어난 인터페이스를 제공하는 것을 목표로 합니다. 이러한 철학은 프론트엔드 개발자로서의 역할을 수행하는 데 큰 도움이 됩니다. 예를 들어, Vite Plugin PWA를 도입하여 사용자에게 최신 업데이트와 알림을 제공함으로써 사용자 만족도를 높인 경험이 있습니다.

이와 같은 문제 해결 능력, 협업 능력, 성능 최적화 기술, 최신 기술 습득 능력, 사용자 중심의 개발 철학을 통해 팀과 프로젝트에 기여할 수 있는 개발자라고 자신 있게 말씀드릴 수 있습니다.

## 나는 어떤 개발자인가

저는 사용자 중심의 혁신적인 개발자가 되고 싶습니다. 사용자 경험을 최우선으로 고려하여 직관적이고 반응성이 뛰어난 애플리케이션을 개발하는 것이 목표입니다. 이를 위해 최신 기술을 지속적으로 학습하고, 새로운 도전을 받아들이는 자세를 유지하고 있습니다.

또한, 팀과 함께 성장하는 개발자가 되고자 합니다. 협업을 통해 팀의 시너지를 극대화하고, 주기적인 피드백과 소통을 통해 프로젝트의 성공을 이끌어 나가는 것이 중요하다고 생각합니다. 저는 팀의 일원으로서 함께 문제를 해결하고, 성과를 공유하며, 성장해 나가는 것을 목표로 하고 있습니다.

지속 가능한 코드 작성에도 중점을 두고 있습니다. 유지보수성과 가독성이 높은 코드를 작성하여, 프로젝트의 장기적인 성공에 기여하고 싶습니다. 이를 위해 코드 리뷰를 환영하며, PR이 올라오면 팀원들이 코드를 어떻게 작성했는지 알 수 있습니다.

마지막으로, 커뮤니티와 지식을 공유하는 개발자가 되고 싶습니다. 기술 블로그를 운영하며 저의 경험과 지식을 공유하고, 오픈 소스 프로젝트에 기여함으로써 개발 커뮤니티에 기여하고자 합니다. 이는 저의 성장에도 큰 도움이 될 뿐만 아니라, 다른 개발자들과의 협력을 통해 더 큰 성과를 이룰 수 있다고 믿습니다.

이와 같은 목표를 통해, 저는 기술적 역량과 협업 능력을 바탕으로 사용자에게 최고의 경험을 제공하는 혁신적인 개발자가 되고자 합니다.

## 이직 사유

저는 이전 Web3 회사에서 많은 것을 배울 수 있었고, 다양한 프로젝트를 통해 제 역량을 키울 수 있었습니다. 안타깝게도, 회사가 폐업하게 되어 새로운 기회를 찾아야 하는 상황이 되었습니다. 그러나 이 경험을 통해 더욱 성장할 수 있었고, 앞으로 더 큰 도전과 기회를 찾고자 합니다.

Web3에 대한 경험을 바탕으로 제가 학습한 것들을 실제 프로젝트에 적용하고 새로운 기여를 할 수 있다고 생각합니다. 제가 보유하는 지식으로 팀과 함께 성장하고 싶습니다.

이번 이직을 통해 저는 제가 가진 기술과 경험을 새로운 환경에서 더욱 발전시키고 싶습니다. 특히, 귀사의 혁신적인 프로젝트와 Web3 기술에 대한 깊은 이해를 바탕으로, 제가 배운 것들을 실무에 적용하고 새로운 기여를 할 수 있을 것이라고 생각합니다. 귀사는 Web3 분야에서 선도적인 위치에 있으며, 제가 가진 기술과 열정을 바탕으로 팀과 함께 성장할 수 있는 최적의 장소라고 생각합니다.

이전 회사에서의 경험은 저에게 많은 교훈을 주었고, 이를 바탕으로 귀사의 발전에 기여할 수 있도록 최선을 다하겠습니다. 또한, 새로운 도전과 기회를 통해 더욱 성장할 수 있는 기회를 주신다면, 귀사와 함께 큰 성과를 이뤄낼 수 있을 것이라 확신합니다.

Remix를 채택한 이유

- Vite로 구성된 리액트 프로젝트에 SSR을 적용해야 했다.
- SEO 작업하고, 브라우저의 부담을 줄일 수 있다고 들었다.
- 어떻게 SSR이 작동하는지 알고 싶었다.
  - Suspense는 renderToReadableStream으로 SSR 성공했다.
- SSR을 적용하고 Loader까지 붙여봤다.
- SSR을 적용하면 외부 API가 CORS 제한이 걸려있을 때에도 문제없이 이용할 수 있다.
- Remix가 React Router DOM을 개발한 회사에서 개발한 프레임워크라는 걸 알고 있었다.
- Loader만 아니라 Action까지 파일 단위로 관리할 수 있었다.
- SSR을 구현하면서 엔트리 파일을 작성했는데 이 구조가 Remix 세팅했을 때 구조와 비슷하더라.
- 메타태그도 더 간편하게 주입 가능

  - React SSR 환경에서는 UI 컴포넌트에서 Loader Hook에서 데이터를 받아온 다음, 메타 태그를 따로 렌더링하는 컴포넌트가 있어야 했다.

- 공식문서에서는 컴포넌트와 Action을 연결할 때 input 컴포넌트마다 State를 연결시키지 않는다.
- 폼 요소가 많을 때에는 비제어되는 컴포넌트도 고려할 수 있을 거 같다.
  - 글자를 입력할 때마다 컴포넌트가 재 렌더링되기 때문
  - 에러 메시지의 경우, onChange 대신 onInput 이벤트 핸들링을 할 수 있을 것이다.

React & Fastify

- SSR은 브라우저의 부담을 줄이지만 서버의 부담을 줄 수 있다.
- 현재 오라클 클라우드에서 개인 프로젝트를 프론트엔드, 백엔드를 전부 하나의 인스턴스에 올리고 있다.
- 조금이라도 서버의 부담을 줄이고 싶었다.
- Fastify가 Express에 비해 서버의 부담을 덜 준다고 알려져있었다. (JSON 직렬화)
  - 공식문서에서도 더 가벼운 라이브러리라고 소개중이었다.
- Server 파일을 직접 작성할 경우, 개발 환경에서 실행할 때 일일이 JS로 변환하기 보다는 NodeJS에 Loader 옵션을 줘서 실행시킬 수 있다는 걸 알게됐다.
- Fastify로 성능이 나아지지 않을 때는, 현재 개인 오라클 클라우드 대신 Cloudflare Pages를 채택할 수도 있을 것 같았다.
- 미들웨어 이슈
  - Static 파일 미들웨어 제공 이슈는 index html 파일을 제외하도록 했다.
  - 압축 미들웨어를 설정했을 때 브라우저가 응답하지 않았는데 content type을 text/html로 설정했다.
- Remix Fastify의 소스 코드를 찾아봄
- 개발용일 때는 Vite 미들웨어를 설정하기 위해 middie를 설치하고, 배포할 때는 Fastify의 플러그인을 채택.

Golang을 백엔드 언어로 고른 이유

- TS만 아니라 다른 언어도 접해보고 싶었다.
- 타입스크립트보다 적은 부담, 문법도 어렵지 않았음
- 하나의 파일로 컴파일됨, 환경변수를 줌으로써 다양한 플랫폼 대응 가능
- Golang은 함수의 리턴값을 에러랑 같이 리턴 가능
- 에러를 꼭 검사하는 프로그래밍 방식이었기 때문에, 타입스크립트 프로그래밍할 때도 비동기 작업의 값이 undefined인지, null인지 확인하는 습관을 들였다.

React 사용 이유

- 단방향 데이터 흐름으로 인해 데이터가 어디서 계산되는지 확인하기 더 빠르다.
- ReactDOMServer의 존재로 SSR이 비교적 어렵지 않았다.
  - renderToString
  - Suspense가 있어야 할 경우 renderToReadableStream

Chromatic Protocol

- useSWR 힘들었던 점

  - useSWR 키를 관리할 때 클래스 인스턴스 등을 넣을 수 없었다.
  - SDK가 클래스 인스턴스를 사용하고 있어서, 인스턴스 대신 식별가능한 값을 키로 부여, 클래스는 Hooks에서 undefined인지 아닌지만 검증
  - 포지션 추가할 때 포지션 갱신을 위해 재요청을 보내는 것 보다는 입력값으로 예상되는 값을 계산하여 로컬 뮤테이션
  - 개발 초기에 자주 발생하던 429 에러 문제가 거의 발생하지 않았다.
  - 기본값으로 창이 다시 포커싱될 때 데이터를 자동으로 갱신한다. 자동으로 갱신되는 것을 막기 위해 컨트랙트의 이벤트로부터 값을 받아 로컬 뮤테이션으로 업데이트시켰다.

- 팀 내 사용하는 웹소켓 라이브러리는 10분이 넘는 시간 후 끊어지는 이슈가 있었는데, 재연결하는 로직이 없었음.

  - Patch package로 우선 라이브러리 직접 확인 후 이슈 등록
  - 핫픽스 배포 후 라이브러리 작업 확인 받음

- 숫자 포매팅

  - 콤마를 표시할 때에는 직접 세 자리 씩 끊어서 쉼표 삽입하는 방식으로 작업
  - Intl.NumberFormat, date-fns으로 리팩토링

- Blur 이벤트 대신 onClickAway 메소드 직접 작성

SolidJS

- React와 비교해서 작은 파일 크기라고 문서에서 소개됨
  - 크기가 작으면 웹 브라우저에서 더 빠르게 로딩할 수 있다.
- 개발을 진행하면서 프로젝트 규모가 커짐에 따라 빌드되는 파일의 크기도 증가한다.
- 협업이 힘들었다.
- React에서 상태가 변수였다면, Solid에서는 상태가 함수(Accessor)라서 어디서 어떤 컴포넌트가 리렌더링되는지 파악하기가 힘들었다.
- UI와 데이터 계산을 분리하는 방법을 찾지 못해 아쉬웠음

OpenAI API 프롬프트

- 그림 API를 사용할 때는 스테이블 디퓨전과는 다르게 문장 형태로 프롬프트를 줄 수 있는 점이 편리했다.
- 필수적으로 넣어야 하는 프롬프트 4줄
- 나름의 규칙을 정해놓았다.
  - 문장은 많이, 문장 당 글자 수는 8개 내외로 적게
  - 인물 및 동물의 경우 특정하는 단어를 작성한다.
  - The painting should be more clear.
  - The painting should adapt watercolor art style.
  - The painting should be extremely detailed.
  - The painting should be much more clear.
  - The painting should include 0 letters.
  - The painting should include 0 text characters.
  - X is male.
  - X is Korean.
  - X is wearing casual outfit.

초기 페이지 렌더링이 느린 이슈

- Performance 50 중반에서 70 중반으로 향상
- 메인 페이지에서는 모든 목록의 이미지를 한번에 렌더링한다.
- 이미지는 지금 S3와 클라우드프론트로 세팅
- 엣지 함수를 설정하면 한달에 2만원 정도, 더 들 수도 있다.
- Intersection Observer로 각 요소가 화면에 보여졌을 때에만 이미지 렌더링
  - 이미지가 완전히 로드되었을 때 visibility를 변경
- 캐시 설정
  - Remix Header에서 직접 캐시 설정을 할 수 있었다.
  - `must-revalidate`로 `max-age` 시간이 지나면 새로 데이터를 받아올 수 있게 했다.
  - 프론트엔드는 Cloudflare DNS Proxy가 적용되어있어서 공유되는 캐시의 유효 기간까지 설정할 수 있도록 `s-max-age`도 적용
    - DDOS 공격을 방어하기 위해 프론트엔드는 DNS Proxy 설정
    - 백엔드는 정해진 아이피, 같은 도메인으로만 접속 가능하도록 CORS
    - 실 방문자 수는 0명인데, 트래픽은 많이 찍힌다.

개인 프로젝트 이유

- 영어 스터디를 하는데 속담이나 비유법을 이해하지 못하는 경우가 종종 있었고, 곧 까먹어버리게 됨

협업

- Web3 프로젝트 초반에 레버리지, 증거금 계산기 직접 실행시켜보고 계산이 잘 안되는 경우 컨트랙트 개발자에게 질문
- 스터디 지속적으로 참석
- 메시지만 보내는 것보다는 직접 음성 채널 방에 접속해서 기다린다.
- 코드 리뷰 받는 걸 두려워하지 않음. 발전의 기회
- 웹 프론트엔드에서 큰 오류가 발생하면 주말에도 접속하여 핫픽스 작업한 경험이 있음
- 웹 서비스 런칭 또는 패치할 때에도 대기
- SDK, 컨트랙트의 코드도 시간될 때마다 PR 확인하고 어떻게 코드가 작동하는지 확인하는 습관 들임
- SDK의 오타나 에러 등을 발견하여 이슈 제보한 적이 있음
- 나는 괜찮은데 디자이너가 이런 면에서는 디자인 적으로 좋지 않을 수 있다는 것도 알게 됨
- 기록하는 습관.
- VSCode Live Share, 화면 공유

- Resize 이벤트
- MutationObserver로 리팩토링

- getBoundingClientRect 메소드는 실행할 때마다 브라우저가 창을 재 렌더링해야함
- Intersection Observer로 리팩토링

- SEO Meta 태그를 불러올 수 없음
- Remix에서 요청이 Bot인지 아닌지에 따라 핸들러 함수를 분리
- 핸들러 함수에 메타태그를 처리하는 컴포넌트가 없었음
- Minified React 에러

NextJS를 사용하지 않는 이유

- NextJS App Router의 중요성은 이해함
- 기존 SSR은 데이터를 불러오는데 시간이 오래 걸림
- 그래서 SSR 중에는 SEO에 필요한 데이터만 가져오고 나머지 데이터는 Hooks으로 중복 요청해서 가져오도록 작업
- Server Components는 페이지 단위가 아니라 컴포넌트 단위로 SSR이 가능하다고 알고 있음
- 각 페이지에 Query Parameter가 붙어있음
- 개발자 채팅 및 블로그 보니 여러가지 이슈가 많았음
- 아직까지 큰 규모의 Nextjs 한 적이 없음
- 당근가서 하고싶다.
