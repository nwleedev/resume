## 면접 대비

**프론트엔드 성능 최적화**

- 첫째, React Window를 사용하여 리스트 가상화와 무한 스크롤을 구현했습니다. 이를 통해 많은 양의 데이터를 한 번에 렌더링하지 않고, 화면에 보이는 부분만 렌더링하여 초기 로드 시간을 크게 단축할 수 있었습니다.
- 둘째, 이미지 최적화를 위해 Lazy Loading을 도입했습니다. Intersection Observer API를 사용하여 사용자가 스크롤하여 이미지가 화면에 나타날 때만 이미지를 로드하도록 설정했습니다.
- 셋째, Lighthouse를 활용하여 성능 점수를 분석하고, 캐시 설정과 코드 스플리팅을 통해 성능을 개선했습니다. 예를 들어, Vite의 manualChunks 코드 스플리팅 기능을 사용하여 라이브러리의 크기가 큰 경우 번들 파일을 여러 개로 나눠 번들 크기를 줄이고, 필요한 시점에만 코드를 로드하도록 했습니다.
- 이러한 최적화 기법을 통해 페이지 로딩 속도를 향상시키고, 사용자 경험을 크게 개선할 수 있었습니다.

**SEO**

- 검색 엔진 최적화(SEO)를 위해 다양한 방법을 사용할 수 있습니다.

- 첫째, 서버 사이드 렌더링(SSR)을 통해 초기 HTML을 완전하게 제공하여 검색 엔진 크롤러가 페이지 내용을 쉽게 인덱싱할 수 있도록 합니다.
- 둘째, 메타 태그를 사용하여 페이지의 제목, 설명, 키워드 등을 명확하게 지정합니다. 예를 들어, `<meta name="description" content="This is an example description">`와 같이 설정할 수 있습니다.
- 셋째, 구조화된 데이터(Structured Data)를 사용하여 검색 엔진이 페이지 내용을 더 잘 이해할 수 있도록 돕습니다. JSON-LD 형식을 사용하여 웹페이지에 추가할 수 있습니다.
- 넷째, 페이지 로딩 속도를 최적화합니다. 이를 위해 이미지 최적화, 코드 스플리팅, 캐싱 등을 활용할 수 있습니다.
- 다섯째, 모바일 최적화가 중요합니다. 반응형 디자인을 사용하여 다양한 디바이스에서 최적의 사용자 경험을 제공합니다.
- 여섯째, 내부 링크 구조를 개선하여 검색 엔진이 사이트의 모든 페이지를 쉽게 탐색할 수 있도록 합니다.
- 마지막으로, 고품질의 콘텐츠를 지속적으로 생성하고, 다른 신뢰할 수 있는 사이트로부터 백링크를 얻어 검색 엔진 랭킹을 높일 수 있습니다.

**단방향 바인딩**

- 단방향 바인딩이 개발에 유리한 이유는 데이터 흐름의 명확성과 디버깅의 용이성에 있습니다.
- 양방향 바인딩은 모델과 뷰가 상호작용하여 자동으로 동기화되기 때문에, 상태 변화의 원인을 추적하기 어렵습니다. 이는 특히 대규모 애플리케이션에서 상태 변화를 예측하고 디버깅하는 데 어려움을 초래합니다.
- 단방향 바인딩은 데이터가 항상 한 방향으로만 흐르기 때문에, 상태 변화의 경로가 명확하게 정의됩니다.
- 모든 상태 변경은 액션을 통해 발생하고, 이는 디스패처를 통해 스토어로 전달되며, 스토어가 상태를 업데이트합니다. 이 과정에서 데이터 흐름이 명확하게 정의되어 있어, 상태 변화의 원인을 쉽게 추적할 수 있습니다.
- 단방향 바인딩은 코드의 일관성과 유지보수성을 높여줍니다. 각 컴포넌트는 자신의 상태만 관리하며, 상태 변화는 중앙 집중식으로 관리되기 때문에, 코드의 복잡성을 줄이고 유지보수를 용이하게 합니다. 이러한 이유로 단방향 바인딩은 복잡한 애플리케이션에서 더욱 유리합니다.

**클로저**

- JavaScript의 클로저는 함수가 선언될 때의 렉시컬 환경(Lexical Environment)을 기억하여, 함수가 선언된 이후에도 그 환경에 접근할 수 있는 기능을 말합니다. 클로저는 변수의 범위를 유지할 수 있어, 데이터 은닉과 상태 유지를 가능하게 합니다.

**협업에서 중요한 요소**

- 제일 중요한 요소는 적극성이라고 생각합니다. 제가 무언가 의사를 전달하기 전까지는 팀원들은 제 생각을 알지 못할 것입니다. 모르는 것이 있을 때는 제가 직접 팀원에게 여쭤봄으로서 팀원도 현재 제 상황을 알고 답변을 받을 수 있습니다. 현재 상황을 설명하고, 어디까지 시도했는지 전달하고, 어떤 방법을 더 생각할 수 있을지 질문드립니다.
- 적극적으로 서로 현재 상황과 알고 모르는 것을 공유함으로서 더 나은 해결책을 찾을 수 있을 것입니다. 이때 타인의 관점에서 생각하여, 나는 알고 있는 것들도 팀원들은 모를 수 있다는 걸 항상 생각해야 합니다.
- 명확한 커뮤니케이션은 프로젝트 목표, 역할 분담, 일정 등을 명확히 전달하고, 팀원 모두가 동일한 목표를 향해 일할 수 있도록 합니다. 예를 들어, 프로젝트 회의에서 각 팀원의 역할과 책임을 명확히 정의하고, 정기적인 업데이트를 통해 진행 상황을 공유합니다.
- 상호 존중은 팀원들의 의견을 경청하고, 다양한 관점을 존중하는 태도입니다. 이는 팀원들이 자유롭게 의견을 나누고, 창의적인 아이디어를 제안할 수 있는 환경을 조성합니다. 또한, 피드백을 주고받을 때 건설적이고 긍정적인 태도를 유지하여, 팀의 협업을 강화하고, 더 나은 결과를 도출할 수 있도록 합니다.
- 서로를 신뢰하고 존중하는 분위기를 조성하여, 업무에 대한 자신감을 가지고 협력할 수 있습니다.

**새로운 라이브러리 도입**

- 최근에 진행한 개인 프로젝트에서 리액트에 서버 사이드 렌더링을 적용하기 위해 Remix 프레임워크를 선택했습니다.
- Remix 없이 리액트에 서버 사이드 렌더링을 적용할 때에는 서버 사이드 렌더링하는 코드를 직접 작성해줘야 했습니다. 컴포넌트에 렌더링하기 전 데이터를 불러오는 역할의 '로더'나 메타 정보를 표시하는 함수도 별도로 관리해야 했습니다. - Remix 프레임워크는 하나의 파일에 로더, 메타데이터, 폼 액션, 컴포넌트를 관리함으로서 생산성을 개선할 수 있습니다.
- 새로운 라이브러리 및 프레임워크를 학습하는 방법은 직접 프로젝트를 만들어보거나 기존 프로젝트의 문제점을 새로운 도구로 해결하는 것이라고 생각합니다.
- 내가 가진 문제를 해결함으로서 왜 이 도구가 필요한지 깨달을 수 있었습니다. 새로운 라이브러리를 활용할 때는 공식문서와 예제 코드를 지속적으로 참고합니다.
- 그 외에도 개발 뉴스레터 및 Hashnode 같은 개발 전문 블로그 사이트를 접속하여 개발 트렌드 및 노하우를 확인할 수 있습니다.

**프론트엔드의 Solid**

- 단일 책임 원칙: 컴포넌트는 하나의 책임만 가져야 합니다. 예를 들어, 데이터를 가져오는 로직과 UI 렌더링 로직을 분리하여, 한 컴포넌트는 데이터를 가져오는 역할만 하고, 다른 컴포넌트는 그 데이터를 받아서 렌더링하는 역할을 합니다. 이렇게 하면 코드의 가독성과 유지보수성이 향상됩니다.
- 예: 데이터 가져오는 Hook, 데이터와 상태를 기반으로 재계산하는 Hook, UI 컴포넌트로 분리할 수 있다.

- 개방 폐쇄 원칙: 컴포넌트는 확장에는 열려 있어야 하지만, 수정에는 닫혀 있어야 합니다. 예를 들어, 새로운 기능을 추가할 때 기존 코드를 수정하지 않고 확장할 수 있도록 컴포넌트를 설계합니다. 이를 위해 HOC(고차 컴포넌트)나 렌더 프롭스를 사용할 수 있습니다.
- 예: 모달 컴포넌트를 설계할 때는 처음에는 Props에 title, textContent, imageContent, button 등의 많은 항목을 계속해서 추가했으나, 지금은 children Props을 통해 Props를 수정하지 않고 컴포넌트를 유동적으로 렌더링할 수 있다.

- 리스코프 치환: 서브클래스나 컴포넌트는 언제나 자신의 기반 클래스나 컴포넌트와 호환되어야 합니다. 이는 상속 관계에서 클래스 간의 일관성을 유지하고, 컴포넌트를 교체해도 기능이 정상적으로 작동할 수 있게 합니다. 예를 들어, 공통 인터페이스를 구현하여 다양한 컴포넌트를 교체 가능하게 만듭니다.
- 예: 입력 컴포넌트를 Generic 프로그래밍을 통해 상태의 타입이 String, Number, Bigint로 교체되더라도 호환되도록 리팩토링.

- 인터페이스 분리: 클라이언트가 사용하지 않는 메서드에 의존하지 않도록 인터페이스를 분리합니다. 리액트에서는 컴포넌트가 불필요한 props를 받지 않도록 설계하는 것이 중요합니다. 예를 들어, 여러 개의 작은 인터페이스를 만들어 필요한 부분만 구현하도록 합니다.
- 예: 방대한 페이지 컴포넌트를 여러 개의 UI 컴포넌트로 분리

- 의존성 역전: 고수준 모듈이 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 합니다. 이는 컴포넌트 간의 결합도를 낮추고, 테스트와 유지보수를 용이하게 합니다. 리액트에서는 컨텍스트 API나 DI(의존성 주입) 패턴을 사용하여 의존성을 주입할 수 있습니다.
- 예: 다크 모드를 스위치할 수 있는 컴포넌트가 있을 때 스위치 컴포넌트까지 props을 전달하는 것이 아닌 Context API를 통해 스위치 컴포넌트가 다른 컴포넌트로 대체되도 다크모드 스위칭이 가능하도록 한다.

**Svelte의 최적화**

- 컴파일 시 최적화된 자바스크립트 파일을 생성한다. 최소한의 DOM 조작을 수행하기 때문에 퍼포먼스를 보장할 수 있다.

- React의 Virtual DOM은 다양한 플랫폼에서 채택될 수 있다.
- React는 서버 사이드 렌더링을 할 수 있는 자체 API를 제공한다.

**Vite로 빌드 후 에셋 파일에 해쉬 값이 생성되는 이유**

- Vite에서 프로젝트를 빌드하면 에셋 파일에 해쉬 값을 작성하는 이유는 캐시 무효화를 위해서입니다. 웹 브라우저는 성능을 최적화하기 위해 정적 파일(CSS, JS, 이미지 등)을 캐싱합니다. 그러나 파일이 업데이트되었음에도 불구하고 브라우저가 이전 버전을 캐싱하고 있으면 최신 변경 사항이 사용자에게 반영되지 않는 문제가 발생할 수 있습니다.
- 이를 방지하기 위해 Vite는 빌드 과정에서 각 에셋 파일 이름에 고유한 해쉬 값을 추가합니다. 예를 들어, index.js 파일이 index.8d7f8d.js와 같이 변경됩니다.
- 해쉬 값은 파일 내용이 변경될 때마다 새로 생성되기 때문에, 파일이 업데이트될 때마다 파일 이름이 달라지게 됩니다.
- 브라우저는 새로운 파일 이름을 인식하고, 이전에 캐싱된 파일이 아닌 최신 파일을 요청하게 됩니다. 이 과정은 캐시 무효화를 통해 사용자에게 항상 최신 버전의 파일을 제공하여, 변경 사항이 즉시 반영되도록 보장합니다.

**유지보수성**

- 첫째, 모듈화를 중요하게 생각합니다. 코드를 작고 독립적인 모듈로 분리하여 각각의 모듈이 하나의 책임만 가지도록 합니다. 예를 들어, Chromatic Protocol 프로젝트에서 각 기능을 독립적인 컴포넌트로 분리하고, 필요에 따라 재사용할 수 있도록 설계했습니다.
- 둘째, 주석과 문서화를 통해 코드의 의도와 동작을 명확하게 기록합니다.
- 마지막으로, 코드 리뷰를 통해 코드 품질을 지속적으로 개선하고, 팀원들과의 협업을 통해 최선의 코딩 방식을 유지하고 있습니다.

- 추가: Hooks을 작성할 때 API 데이터를 불러오는 Hooks과 데이터를 계산하는 Hooks를 분리하여 데이터를 계산하는 Hooks을 테스트할 수 있었습니다. 보통 함수를 분리할 때는 API 같은 외부 요소와 상호작용하는 액션과 데이터를 기반으로 새로운 값을 도출하는 계산으로 분리한다. API 호출은 네트워크 오류 등으로 데이터를 보장할 수 없고, 계산 부분을 분리해야 테스트하기 원활해진다. 어디에서 원인이 발생했는지 알 수 있었다.

**Observer**

- 마지막으로 설정한 Textarea의 크기를 로컬 스토리지에 기록하기 위해 getBoundingClientRect를 호출하면 브라우저가 Textarea 및 하위 요소를 다시 reflow합니다. MutationObserver를 채택하면 재렌더링없이 크기를 가져올 수 있다.
- Textarea의 크기를 로컬 스토리지에 저장하기 위해 크기가 바뀔 때마다 계속 저장했다. 요소의 길이와 높이를 읽는 과정에서 reflow가 계속 발생할 수 있어서 Document의 beforeunload 이벤트를 받아서 페이지가 닫힐 때에만 높이를 가져다 저장하고 재접속시 재사용한다.

**캐시 방법**

- Remix의 응답 헤더 캐시
- Cloudflare의 캐시 설정
- 새 배포 후 Purge

**캐시 무효화**

- 빌드할 때 해쉬 값 생성
- 타임스탬프
- 서비스 워커
- 파일에 버전

**React 프로젝트는 어떤 패턴을 사용해야 하는가**

- MVVM 패턴

- 컴포넌트가 뷰의 역할을 한다. 모델의 역할은 API 호출로 받은 데이터이다.

- 리액트 Hooks가 뷰모델 역할을 할 수 있다. 뷰모델 내에서 컴포넌트 상태를 정의하고 어떻게 상태를 업데이트할지, 상태를 기반으로 데이터를 어떻게 계산할지 결정함으로써 뷰와 모델 간 데이터를 바인딩한다.

- 뷰는 뷰모델에서 업데이트한 변수를 기반으로 UI를 적용시키는 역할만 수행한다.

- Flux 패턴은 Redux 및 Context API 전역 상태를 관리할 때 사용될 수 있을 것이다. 전체적인 스토어에서 하위 컴포넌트로 데이터를 전달하는 방식이기 때문이다.

## 내 질문

기본

- 더 수준 높은 프론트엔드가 아닌 2년차의 프론트엔드 개발직을 채용하는 이유가 무엇인가요?
- 코드 리뷰 시스템은 어떻게 운영되고 있나요?
- 협업은 주로 어떻게 구성되어 있나요?
- 현재 그루우의 최우선 목표는 무엇인가요?
- PC 웹 버전도 개발할 계획이 있을까요? 없다면 프론트엔드 개발자가 추후에 모바일 앱 개발에도 참여할 수 있을까요? 리액트 네이티브를 하면서 어떤 이슈를 맞이했으며 어떻게 해결했는지 알 수 있을까요?
- 브랜치 관리 및 배포 프로세스는 어떻게 되나요?
- 식물을 키우는 공간, 환경 조건, 건강 상태 등을 주관적인 데이터를 수치화하는 방법은 무엇일까요?
- CEO도 강의를 수강한다고 했는데 강의를 선택하는 기준?

회사 목표와 비전

- 회사의 장기적인 목표는 무엇인가요? 그리고 이를 달성하기 위해 어떤 전략을 사용하고 계신가요?
- 앞으로 5년 내에 회사가 도달하고 싶은 비전은 무엇인가요? 그리고 이를 실현하기 위해 현재 어떤 노력을 기울이고 있나요?
- 현재 회사가 가장 집중하고 있는 주요 목표는 무엇인가요? 이 목표를 달성하기 위한 주요 도전 과제는 무엇인가요?

팀 문화와 작업 방식

- 이 팀은 어떤 가치와 문화를 중요시하나요? 이러한 가치와 문화는 일상 업무에서 어떻게 실천되고 있나요?
- 팀 내에서 협업과 의사소통은 어떻게 이루어지나요? 구체적인 사례를 들어 설명해 주실 수 있나요?
- 최근 팀이 직면했던 주요 문제는 무엇이었고, 이를 어떻게 해결하셨나요? 이 과정에서 가장 중요한 교훈은 무엇이었나요?
- 팀원 간의 피드백 프로세스는 어떤 형태로 이루어지나요? 피드백을 효과적으로 주고받기 위해 어떤 방법을 사용하고 있나요?

회사 프로젝트와 성과

- 최근 회사가 성공적으로 완료한 프로젝트는 무엇인가요? 이 프로젝트가 회사에 어떤 영향을 미쳤나요? 공식 홈페이지에서 앱을 첫 빌드한 것을 확인했습니다.
- 이러한 프로젝트를 통해 배운 것 중 가장 중요한 것은 무엇인가요? 이 교훈을 어떻게 향후 프로젝트에 적용하고 있나요?
- 현재 진행 중인 주요 프로젝트는 무엇이며, 이 프로젝트가 회사에 끼칠 영향은 무엇인가요? 이 프로젝트에서 제가 맡게 될 역할은 무엇일까요?

직원 성장과 발전 기회

- 회사는 직원의 성장을 위해 어떤 교육 프로그램이나 지원을 제공하나요? 이러한 프로그램이 실제로 어떻게 운영되고 있나요?
- 직무 연계 교육 외에 직원들이 성장할 수 있는 기회는 무엇인가요? 예를 들어, 회사에서 제공하는 멘토링 프로그램이나 자율 학습 기회가 있나요?
- 회사 내에서 커리어 발전의 기회는 어떻게 주어지나요? 승진이나 직무 변경 등의 기회가 주어지는 과정에 대해 설명해 주실 수 있나요?

회사 문화와 가치

- 회사가 자랑스러워하는 문화적 요소는 무엇인가요? 이러한 문화가 직원들에게 어떤 긍정적인 영향을 미치고 있나요?
- 회사가 중요하게 생각하는 핵심 가치는 무엇인가요? 이러한 가치를 직원들이 일상 업무에서 실천할 수 있도록 어떤 노력을 기울이고 있나요?
- 회사의 가치를 일상 업무에서 어떻게 실천하고 있나요? 구체적인 사례를 들어 설명해 주실 수 있나요?
